# This file is part of Pynguin.
#
# Pynguin is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pynguin is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Pynguin.  If not, see <https://www.gnu.org/licenses/>.
"""Provides a test cluster."""
import abc
import importlib
import inspect
import logging
from typing import List, Type, Optional, Callable, Dict, Set, cast

import pynguin.configuration as config

from pynguin.typeinference import typeinference
from pynguin.typeinference.strategy import InferredSignature
from pynguin.typeinference.typehintsstrategy import TypeHintsInferenceStrategy


class GenericAccessibleObject(metaclass=abc.ABCMeta):
    """Abstract base class for something that can be accessed."""

    def __init__(self, owner: Optional[Type]):
        self._owner = owner

    @abc.abstractmethod
    def generated_type(self) -> Optional[Type]:
        """Provides the type that is generated by this accessible object."""

    @property
    def owner(self) -> Optional[Type]:
        """The type which owns this accessible object."""
        return self._owner


class GenericCallableAccessibleObject(
    GenericAccessibleObject, metaclass=abc.ABCMeta
):  # pylint: disable=W0223
    """Abstract base class for something that can be called."""

    def __init__(
        self, owner: Optional[Type], inferred_signature: InferredSignature
    ) -> None:
        super().__init__(owner)
        self._inferred_signature = inferred_signature

    def generated_type(self) -> Optional[Type]:
        return self._inferred_signature.return_type


class GenericConstructor(GenericCallableAccessibleObject):
    """A constructor."""

    def __init__(self, owner: Type, inferred_signature: InferredSignature) -> None:
        super().__init__(owner, inferred_signature)
        assert owner

    def generated_type(self) -> Optional[Type]:
        return self.owner


class GenericMethod(GenericCallableAccessibleObject):
    """A method."""

    def __init__(
        self, owner: Type, method: Callable, inferred_signature: InferredSignature
    ) -> None:
        super().__init__(owner, inferred_signature)
        assert owner
        self._method = method


class GenericFunction(GenericCallableAccessibleObject):
    """A function, which does not belong to any class."""

    def __init__(
        self, function: Callable, inferred_signature: InferredSignature
    ) -> None:
        super().__init__(None, inferred_signature)
        self._function = function


class GenericField(GenericAccessibleObject):
    """A field."""

    def __init__(self, owner: Type, field: str, field_type: Optional[Type]) -> None:
        super().__init__(owner)
        self._field = field
        self._field_type = field_type

    def generated_type(self) -> Optional[Type]:
        return self._field_type

    @property
    def field(self) -> str:
        """Provides the name of the field."""
        return self._field


class TestCluster:
    """A test cluster which contains all methods/constructors/functions
    and all required transitive dependencies."""

    primitives = {int, str, bool, float, complex}

    _logger = logging.getLogger(__name__)

    def __init__(self, module_names: List[str]):
        # TODO(fk) Extract this from the constructor to a builder...
        self._generators: Dict[Type, Set[GenericAccessibleObject]] = cast(
            Dict[Type, Set[GenericAccessibleObject]], dict()
        )

        self._accessible_objects_under_test: Set[GenericAccessibleObject] = set()
        # TODO(fk) use configured inference strategy
        inference = typeinference.TypeInference(
            strategies=[TypeHintsInferenceStrategy()]
        )

        self._logger.debug("Generating test cluster")
        for module in module_names:
            self._logger.debug("Analyzing module %s", module)
            imported = importlib.import_module(module)
            for class_name, klass in inspect.getmembers(imported, inspect.isclass):
                self._logger.debug("Analyzing class %s", class_name)
                # TODO(fk) handle multiple strategies?
                generic_constructor = GenericConstructor(
                    klass, inference.infer_type_info(klass.__init__)[0]
                )
                self._add_generator(generic_constructor)
                self._accessible_objects_under_test.add(generic_constructor)
                self._add_callable_dependencies(generic_constructor, 1)

                for method_name, method in inspect.getmembers(
                    klass, inspect.isfunction
                ):
                    # TODO(fk) why does inspect.ismethod not work here?!
                    self._logger.debug(
                        "Analyzing method %s.%s", class_name, method_name
                    )
                    if method_name == "__init__":
                        # The constructor is handled elsewhere.
                        continue
                    generic_method = GenericMethod(
                        klass, method, inference.infer_type_info(method)[0]
                    )
                    self._add_generator(generic_method)
                    self._accessible_objects_under_test.add(generic_method)
                    self._add_callable_dependencies(generic_method, 1)
                # TODO(fk) how do we find attributes?
            for function_name, funktion in inspect.getmembers(
                imported, inspect.isfunction
            ):
                self._logger.debug("Analyzing function %s", function_name)
                generic_function = GenericFunction(
                    funktion, inference.infer_type_info(funktion)[0]
                )
                self._add_generator(generic_function)
                self._accessible_objects_under_test.add(generic_function)
                self._add_callable_dependencies(generic_function, 1)

    def _add_callable_dependencies(
        self, call: GenericCallableAccessibleObject, recursion_level: int
    ) -> None:
        """Add required dependencies."""
        self._logger.debug("Find dependencies for %s", call)
        if recursion_level > config.INSTANCE.max_cluster_recursion:
            return

        # TODO(fk) Implement me

    @property
    def accessible_objects_under_test(self) -> Set[GenericAccessibleObject]:
        """Provides all accessible objects that are under test."""
        return self._accessible_objects_under_test

    def _add_generator(self, generator: GenericAccessibleObject) -> None:
        """Add the given accessible as a generator, if the type is known and not NoneType."""
        type_ = generator.generated_type()
        if type_ is None or type_ is type(None):  # noqa: E721
            return
        if type_ in self._generators:
            self._generators[type_].add(generator)
        else:
            self._generators[type_] = {generator}

    def get_generators_for(self, for_type: Type) -> Set[GenericAccessibleObject]:
        """
        Retrieve all known generators for the given type which are
        known within the test cluster.
        """
        if for_type in self._generators:
            return self._generators[for_type]
        return set()
